<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">
		<title>CSS 방법론</title>
		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">
		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/league.css" id="theme">
		<!-- <link rel="stylesheet" href="css/theme/ember.css" id="theme"> -->
		<!-- Code syntax highlighting -->
		<!-- <link rel="stylesheet" href="lib/css/monokai_sublime.css"> -->
		<!-- <link rel="stylesheet" href="https://highlightjs.org/static/demo/styles/atom-one-dark.css"> -->
		<!-- <link rel="stylesheet" href="https://highlightjs.org/static/demo/styles/monokai-sublime.css"> -->
		<!--<link rel="stylesheet" href="https://highlightjs.org/static/demo/styles/monokai.css">       -->
		<link rel="stylesheet" href="https://highlightjs.org/static/demo/styles/monokai-sublime.css">
		<link rel="stylesheet" href="https://code.cdn.mozilla.net/fonts/fira.css">
		<link rel='stylesheet' href='lib/font/devicons/devicons.css'>
		<style type="text/css">
		.reveal{font-size:24px}
		.txl{text-align:left;display:inline-block}
		.devicons-javascript{color:#f5de19}
		.devicons-html5{color:#e44f26}
		.devicons-css3{color:#1572b6}
		.devicons-npm{color:#a23332}
		.devicons-sass{color:#cd6799}

		div.ex_preview{margin:40px}
		div.ex_preview:hover{color:inherit;border:inherit}
		div.ex_preview .blackborder{display:inline-block;border:3px solid #000;padding:10px 20px;color:#fff;border-radius:10px}

		.bluebg{background-color:blue}
		.redbg{background-color:red}
		</style>
		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>
		<div class="reveal">
			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<img src="img/css_logo.png" alt="css" width="160">
					<h1 style="margin-bottom:60px;font-size:50px;letter-spacing:normal">CSS 방법론<br><span style="font-size:30px">(OOCSS, BEM, SMACSS)</span></h1>
					<p>2018. 06. 29</p>
					<p>IT 개발2팀 UI파트 - 김재호</p>
				</section>

				<section>
					<h2>The Agenda</h2>
					<ul>
						<li>CSS 설계의 중요성</li>
						<li>OOCSS</li>
						<li>BEM</li>
						<li>SMACSS</li>
					</ul>
				</section>

				<section>
					<section>
						<h2>CSS 설계의 중요성</h2>
					</section>

					<section>
						<h2>CSS 개발의 문제점</h2>
						<p>CSS를 작성하는 것이 쉽지만 한 번 확장하고 관리하기는 어려움</p>
						<ul>
							<li>CSS의 전역환경</li>
							<li>일관적이지 않은 코드 구조, 각자 다른 사고 방식 스타일 정의</li>
							<li>지나치게 복잡한 선택자</li>
							<li>동일 요소에 대한 중복 설정, 불필요한 CSS의 증가</li>
							<li>CSS 셀렉터 우선순위 or !important 사용</li>
							<li>CSS (표현), JS (동작), HTML (내용) 간 명확한 분리가 안됨 (높은 결합도)</li>
						</ul>

<!--

<p>그 동안 무엇이 CSS의 유지보수를 어렵게 했는지 알아봅시다.</p>

CSS를 사용함에 있어서 '잘 나오면 장땡'이라는 자세는 옳지 않다고 생각하고,
 SASS를 사용하면 코드의 관리측면이나 효율성 측면에서 좋지만, 이 글에서는 그런 것들을 잠시 내려두고 약간 원론에 가까운 이야기를 하려고 한다.

방법론은 방법론이다. 참고용 이지 바이블이 아니다.
재사용가능하고 유지보수를 잘 할수 있는 목적이 중요하다.
CSS preprocessor(Sass, Less 등) 는 선택이 아니라 필수다.
분명한 점은 앞으로 CSS를 작성할때는 한번 더 생각할 것이고, 고민할 것이다. 나만의 방법론, 팀의 방법론을 만들어 가는것이 중요한것 같다.


CSS설계는 매우 중요한 것입니다.

일정한 규칙이 없으면
각자가 다른 사고 방식에서 스타일 정의 하고 불필요한 CSS가 늘어나거나
본인이 아니면 모르는 규칙이 발생해 유지보수 하기 어렵게 되어 버립니다.



## 일관적이지 않은 코드 구조
* 작성 규칙이 통일되지 않았다
* 동일 요소에 대한 중복 설정이 많아진다


## 높은 결합도
* 표현(css), 행위(js), 텍스트(html) 간에 명확한 분리가 이루어지지 않았다
* 뷰의 일부 요소가 전체 요소 및 행위(js)에 영향을 미치고 있다
* 스타일 적용 깊이 및 선택자 덮어쓰기도 html 구조를 바꾸기 어렵게 한다 -->
					</section>

					<section>
						<h2>사이트 규모가 커질수록..</h2>
						<p>유지 보수가 불가능한 코드 -> 귀차니즘, 중복, 코드분석 시간 -> 새로운 기능의 개발 속도 저하</p>
					</section>

					<section>
						<h2>CSS 작성 방법</h2>
						<!-- <p>처음에는 CSS가 쉽다고 느껴질 수도 있습니다. 하지만 시간이 지날수록 CSS가 얼마나 복잡한 언어인지 알게됩니다.</p> -->
						<ul>
							<li>적절한 의미 사용 (시맨틱)</li>
							<li>중첩 선택자</li>
							<li>모듈화</li>
							<li>명명 규칙</li>
							<!-- <li>단일 책임 원칙</li> -->
						</ul>
					</section>

					<section>
						<h2>적절한 의미 사용 (시맨틱)</h2>
						<p>HTML에서 시맨틱은 적절한 마크업 태그 사용</p>
						<pre><code class="html">
	&lt;!-- Bad --&gt;
	&lt;div class="footer"&gt; ... &lt;/div&gt;

	&lt;!-- Good --&gt;
	&lt;footer"&gt; ... &lt;/footer&gt;
                        </code></pre>
					</section>

					<section>
						<h2>의미론적 CSS</h2>
						<ul>
							<li>컨텐츠의 성격과 기능을 전달하는 클래스명</li>
							<!-- <li>구조적 의미와 기능을 전달하는 클래스명</li> -->
							<li>이해하기 쉬운 클래스명</li>
							<li>시맨틱 CSS는 훨씬 더 추상적이고 주관적</li>
						</ul>

<!-- HTML과 CSS를 책처럼 읽을 수 있어야합니다.
마치 등장인물과 그 관계를 말해주는 이야기처럼 말입니다.
결국 더 많은 시맨틱 CSS는 코드를 잘 유지할 수 있도록 만들어줍니다.
단일 책임 원칙
느슨하게, 단일 책임 원리는 모든 모듈 또는 코드 덩어리 (함수 등)는 하나의 작업을 잘하고 하나의 작업 만 수행해야한다고 말합니다.
이것의 이점은 주로 유지 보수성과 확장성에 있습니다. -->
					</section>


					<section>
						<h2>중첩 선택자</h2>
						<p>만약 선택자가 이렇게 길어진다면, 다음과 같은 CSS를 작성하고 있을 가능성이 높음</p>

						<pre><code class="css">
	.container .content .profile { ... }
                        </code></pre>

						<ul>
							<li>HTML과 밀접하게 엮여있다.</li>
							<li>너무 구체적이다.</li>
							<li>재사용할 수 없다.</li>
						</ul>
					</section>

					<section>
						<h2>특정도 평준화</h2>
						<p>더 높은 우선순위 싸움 → 악순환</p>

						<table class="table">
							<thead>
							<tr class="header">
							<th>Selector</th>
							<th>ID (a)</th>
							<th>Classes (b)</th>
							<th>Elements (c)</th>
							<th>Specificity (a-b-c)</th>
							</tr>
							</thead>
							<tbody>
							<tr>
							<td>p</td>
							<td style="text-align:center">0</td>
							<td style="text-align:center">0</td>
							<td style="text-align:center">1</td>
							<td style="text-align:center">0-0-1</td>
							</tr>
							<tr>
							<td>p#foo</td>
							<td style="text-align:center">1</td>
							<td style="text-align:center">0</td>
							<td style="text-align:center">1</td>
							<td style="text-align:center">1-0-1</td>
							</tr>
							<tr>
							<td>p.bar1</td>
							<td style="text-align:center">0</td>
							<td style="text-align:center">1</td>
							<td style="text-align:center">1</td>
							<td style="text-align:center">0-1-1</td>
							</tr>
							<tr>
							<td>p.bar1.bar2.bar3</td>
							<td style="text-align:center">0</td>
							<td style="text-align:center">3</td>
							<td style="text-align:center">1</td>
							<td style="text-align:center">0-3-1</td>
							</tr>
							</tbody>
						</table>

					</section>


					<section>
						<h2>모듈화</h2>
						<ul>
							<li>디자인을 구성 요소(component)로 분해</li>
							<li>코드가 분리 될수록 클래스 간 상호 의존성이 낮음</li>
							<li>id 보다 class를 활용 (재사용 불가능)</li>
							<li>태그 선택자의 사용을 지양</li>
							<!-- <li>탐색레벨을 낮고 단순하게 유지</li> -->
						</ul>
					</section>


					<section>
						<h2>명명 규칙</h2>
						<p>쉬운 유지보수, 코드의 재사용, 확장 가능, 직관적인 네이밍을 고려한 설계 방법</p>

						<ul>
							<li>OOCSS (Object Oriented CSS)</li>
							<li>BEM (Block Element Modifier)</li>
							<li>SMACSS (Scalable and Modular Architecture for CSS)</li>
						</ul>

						<!--
						<p>일관된 방법, 체계적인 방법, 이런게 정리되면 그게 바로 방법론</p>
						<p>
						이렇게 여러개 알아볼 필요 없이 하나만 선택해서 쓰면 되는 것 아니냐는 생각이 들 수 있다.
						하지만 각 방법론들은 서로에게 영감을 주는 관계이므로 하나씩 이해해볼 필요가 있다.
						그리고 마지막에 각 방법론에서 쓰이는 방법들이 서로 어떻게 연결되는지 생각해보려고 한다.
						</p> -->
					</section>

				</section>


				<section>
					<section>
						<h2>OOCSS<br>(Object Oriented CSS)</h2>
					</section>

					<section>
						<h2>OOCSS의 2가지 원칙</h2>
						<p>OOCSS는 객체 지향에 따라 고안된 설계 방식</p>
						<ul>
							<li>구조와 외형의 분리 (Separate structure and skin)</li>
							<li>컨테이너와 내용 분리 (Separate container and content)</li>
							<!-- <li>코드 재사용성이 높아져 코드량이 줄고, 유지보수성도 높아지는 장점</li> -->
							<!-- <li>반면, 마크업에 동일한 클래스를 여러 곳에 사용하므로 코드가 지저분해지는 단점</li> -->
							<!-- <li>코드 재사용성을 높이고, 더 빠르고 효율적이며 뭔가 추가하기 쉽고 유지보수하기 용이한 스타일시트
							OOCSS의 목표는 다양한 스타일 규칙 전체에서 동일한 속성의 중복을 줄이는 것 자손선택자의 사용을 지양</li> -->

						</ul>
					</section>

					<section>
						<h2>구조와 외형의 분리</h2>
						<p>기본적인 구조와 반복 정의되는 외형은 따로 정의 (공통 스타일 추상화)</p>
						<ul>
							<li>구조 : width, height, border, padding, margin</li>
							<li>외형 : color, border-color, font-color, background-color</li>
						</ul>
						<!-- <p>결과적으로 이 원칙의 목적은 재사용과 유지보수</p> -->
					</section>


					<section>
                        <div class="ex_preview">
	              			<a href="#" class="blackborder bluebg">장바구니</a>
							<a href="#" class="blackborder redbg">바로구매</a>
						</div>

						<pre><code class="html">
	&lt;a href="#" class="blackborder bluebg"&gt;장바구니&lt;/a&gt;
	&lt;a href="#" class="blackborder redbg"&gt;바로구매&lt;/a&gt;
                        </code></pre>

						<pre><code class="css">
	.body_em .btn_wrap .redbg {
		background-color: yellow;
	}
                        </code></pre>

                        <ul>
                        	<li>유연하게 사용가능</li>
                        	<!-- <li>디자인 변경을 예측해서 명명하기</li> -->
							<li>재사용성을 확보하는 이름</li>
                        	<li>클래스명에 의미를 갖게 할 것 (시맨틱)</li>
                        </ul>
					</section>

					<section>
						<h2>의미론적 CSS</h2>
						<p>DRY (Don't Repeat Yourself) CSS</p>
						<pre><code class="html">
	&lt;a href="#" class="cartbtn"&gt;장바구니&lt;/a&gt;
	&lt;a href="#" class="buybtn"&gt;바로구매&lt;/a&gt;
                        </code></pre>
						<pre class="vertical"><code class="css">
	.cartbtn{
		display:inline-block;
		padding:10px 20px;
		color:#fff;
		border:3px solid #000;
		border-radius:10px;
		background-color:blue
	}
                        </code></pre>
                        <pre class="vertical"><code class="css">
	.buybtn{
		display:inline-block;
		padding:10px 20px;
		color:#fff;
		border:3px solid #000;
		border-radius:10px;
		background-color:red
	}
                        </code></pre>
					</section>

					<section>
						<h2>OOCSS Style</h2>
						<p>기본 구조가 독립적으로 지정되어 있기 때문에<br>향후 다른 색의 버튼이 추가되더라도 외형 스타일만 추가로 정의</p>
						<!--
						계획을 세우고 미리 생각해 보면 일반적인 스타일을 추상화하여 CSS
						이제 모든 요소가 클래스를 사용하고 공통 스타일이 재사용 가능한 "스킨"으로 결합되며 불필요하게 반복되는 요소는 없습니다.
						우리는 모든 요소에 "스킨"클래스를 적용하기 만하면 코드와 적은 재사용 가능성을 제외하고 첫 번째 예제가 생성하는 것과 동일한 결과가됩니다 .
						-->

						<pre><code class="html">
	&lt;a href="#" class="btnbase cart"&gt;장바구니&lt;/a&gt;
	&lt;a href="#" class="btnbase buy"&gt;바로구매&lt;/a&gt;
                        </code></pre>

						<pre class="vertical"><code class="css">
	/* 버튼 구조: 공통적인 구조 지정 */
	.btnbase{
		display:inline-block;
		padding:10px 20px;
		color:#fff;
		border:3px solid #000;
		border-radius:10px;
	}
                        </code></pre>
                        <pre class="vertical"><code class="css">
	/* 버튼 외형 */
	.cart{
		background-color:blue
	}

	.buy{
		background-color:red
	}
                        </code></pre>
					</section>

					<section>
						<h2>컨테이너와 내용의 분리</h2>
						<ul>
							<li>위치에 의존하지 않는 스타일 정의</li>
							<li>어떤 태그라도 동일한 외형 제공</li>
							<li>어디에서나 재사용이 가능한 클래스 기반 모듈 구축</li>
						</ul>
					</section>

					<section>
						<p>태그에 스타일 지정 → 클래스명을 부여하고 스타일 지정</p>
						<p>태그가 변경되어도 CSS를 바꿀 필요가 없음</p>
						<pre class="vertical"><code class="html">
	&lt;!-- Bad --&gt;
	&lt;h2&gt; ... &lt;/h2&gt;
                        </code></pre>

						<pre class="vertical"><code class="css">

	h2 { font-size:16px }
                        </code></pre>

                        <pre class="vertical"><code class="html">
	&lt;!-- Good --&gt;
	&lt;h3 class="subtitle"&gt; ... &lt;/h3&gt;
	&lt;span class="subtitle"&gt; ... &lt;/span&gt;
                        </code></pre>

                        <pre class="vertical"><code class="css">

	.subtitle { font-size:16px }

                        </code></pre>
					</section>

					<section>
						<p>장소를 한정하고 스타일 지정 → 종속되지 않는 클래스명을 부여하고 스타일 지정<!-- <br>장소를 한정하지 않기 때문에, 사이드 바, 주요 지역에서도 재사용 가능 --></p>
						<p>구조적 상황에 관계없이 문서 어느 곳에서나 재사용 가능</p>

<!-- 이제 우리는 불필요하게 스타일을 복제 하고 그것을 인식하지 못할 수도 있습니다.
OOCSS를 사용하면 다른 요소들 사이에 공통적 인 점에 대해 미리 생각해 두었다가 공통적 인 기능을 모듈이나 객체로 분리하여 어디서든 재사용 할 수 있습니다.
위 예제의 하위 선택기를 사용하여 선언 된 스타일 은 특정 컨테이너 (이 경우에는 세로 막대 또는 바닥 글)에 종속되므로 재사용 할 수 없습니다 .
OOCSS의 클래스 기반 모듈 건물을 사용할 때 우리는 스타일이 포함 된 요소에 의존하지 않도록합니다.  -->


                        <pre class="vertical"><code class="css">
	.header .logo {
		background-image:url(img/logo.png);
		width: 250px;
		height: 25px;
	}

	.footer .logo {
		background-image:url(img/logo-small.png);
		width: 100px;
		height: 15px;
	}
                        </code></pre>
                        <pre class="vertical"><code class="css">
	.logo-large {
		background-image:url(img/logo.png);
		width: 250px;
		height: 25px;
	}

	.logo-small {
		background-image:url(img/logo-small.png);
		width: 100px;
		height:15px;
	}
                        </code></pre>
					</section>

					<!--
					<section>
						<h2>유의사항</h2>
						<ul>
							<li>파생된 CSS셀렉터 사용 금지 ex) .box a {}</li>
							<li>ID 셀렉터 사용 금지 ex) #box {}</li>
							<li>태그 셀렉터 사용 금지 ex) div.box {}</li>
							<li>!important 사용 금지</li>
						</ul>
					</section>
					-->

					<section>
						<h2>OOCSS 장/단점</h2>
						<ul>
							<!-- <li>코드 재사용성을 높이고, 더 빠르고 효율적이며 추가하기 쉽고 유지보수 용이</li> -->
							<li>좋은 점 : 재사용함으로써 코드 양을 줄임 (DRY 원칙)</li>
							<li>나쁜 점 : 대부분 클래스가 공통적이기 때문에 특정 요소 스타일 변경 시<br>CSS뿐만 아니라 마크업에 클래스를 추가해야 할 가능성이 높음</li>
						</ul>
					</section>


				</section>


				<section>
					<section>
						<h2>BEM<br>(Block Element Modifier)</h2>
					</section>

					<section>
						<h2>BEM</h2>
						<p>단순하고 쉽게 이해할 수 있는 견고한 구조를 가진 CSS 작성</p>
						<!-- <p>CSS 클래스를 구조화, 이름을 지정, 코드의 유연성과 유지 관리 가능성을 높이는 방법</p> -->
						<ul>
							<li>Block, Element, Modifier로 나누어 클래스명 기술</li>
							<li>엄격한 명명 규칙이 특징 (class만 사용. ID, 태그 사용 금지)</li>
							<li>클래스명이 용도, 형태를 의미하므로 직관적인 것이 장점, 길고 복잡해지는 것이 단점</li>
						</ul>


							<!--
							<li>selector는 무엇을 하는지는 이름만 보고 알 수 있습니다.</li>
							<li>selector를 보기만 해도 어디에 사용할 수 있는지 알 수 있습니다.</li>
							<li>클래스 이름 간의 관계를 알기 위해서는 클래스 이름을 살펴 보기만 해도 된다.</li> -->

						<!-- <p>
						서로 다른 역할을 수행하는 CSS 클래스를 차별화
						각각의 요소들이 무슨 역할을 하는지 구분해둔 것만 보고도 이해
						마크업에서는 명확한 역할을 구분
						OOCSS와 함께 자손선택자를 지양

						OOCSS을 보완하는 역할
						BEM은 하나의 클래스로 자손역할을 하는 부분까지 표현하는 것이 특징
						명명규칙에 익숙하지 않은 개발자들에게는 다소 어려운 부분으로 다가와서 생산력 저하
						너무 길어질 우려가 있음

						클래스 이름이 상당히 지저분해 지고

						</p>

						#OOCSS와 BEM

						CSS와 HTML 사이의 명확하고, 엄격한 관계를 형성하는 데에 도움
						재사용 가능하고, 작성 가능한 컴포넌트를 만드는 데에 도움

						보다 적은 중첩과 낮은 특수성
						확장성 있는 스타일시트를 작성

						OOCSS는 당신의 스타일시트를 "객체"의 모음

						(한 웹사이트에서 독립적으로 사용되는, 재사용 가능하고 반복 가능한 단편들)
						으로 생각하게 만드는 CSS 작성 방식입니다. -->
					</section>


					<section>
						<h2>Block</h2>
						<ul>
							<li>재사용 가능한 컴포넌트 (코드의 구조적 덩어리)</li>
							<li>클래스명은 하나의 단어 사용, 길어질 경우 단일 하이픈(-)으로 구분</li>
							<li>ex) logo / login form / navigation / header / footer</li>
						</ul>
					</section>

					<section>
						<div><img src="img/stick_man_b.png" alt="" style="width:50%;margin:0"></div>

                        <pre><code class="html">
	&lt;div class="stick-man"&gt; ... &lt;/div&gt;
                        </code></pre>

                        <pre><code class="css">
	.stick-man { ... }
                        </code></pre>
					</section>


					<section>
						<h2>Element</h2>
						<ul>
							<!-- <li>블록에 의존하는 하위 구성 요소</li> -->
							<!-- <li>특정 기능을 수행하는 블록 내의 하위 구성 요소</li> -->
							<!-- <li>블록 안에만 존재 하는 하위 요소</li> -->
							<li>블록 외부에서 사용할 수 없는 블록내의 구성 요소</li>
							<li>블록 맥락에서만 의미가 있어야 함</li>
							<!-- <li>독립적 의미가 없고 블록에 의미적으로 연결</li> -->
							<li>클래스명은 해당 블록 이름과 밑줄 두 개(__) 추가 후 작성</li>
							<!-- <li>클래스 간 서로 의존성이 없어야 함</li> -->
						</ul>
					</section>


					<section>
						<div><img src="img/stick_man_e.png" alt="" style="width:50%;margin:0"></div>
                        <pre><code class="html">
	&lt;div class="stick-man"&gt;
		&lt;div class="stick-man__head"&gt;&lt;/div&gt;
		&lt;div class="stick-man__arms"&gt;&lt;/div&gt;
		&lt;div class="stick-man__feet"&gt;&lt;/div&gt;
	&lt;/div&gt;
                        </code></pre>

                        <pre class="vertical"><code class="css">
	/* Bad: 의존성 X */
	.stick-man .stick-man__head { ... }
	div.stick-man__head { ... }
                        </code></pre>

                        <pre class="vertical"><code class="css">
	.stick-man__head { ... }
	.stick-man__arms { ... }
	.stick-man__feet { ... }
                        </code></pre>

					</section>

					<section>
						<h2>깊이 최소화</h2>
						<p>요소의 요소를 만들 필요가 있다면 (block__element__element X)<br>DOM 트리를 모방 하려고 하지 마세요</p>
                        <pre><code class="html">
	&lt;!-- Bad --&gt;
	&lt;div class="stick-man"&gt;
		...
		&lt;div class="stick-man__arms"&gt;
			&lt;span class="stick-man__arms__left"&gt;&lt;/span&gt;
			&lt;span class="stick-man__arms__right"&gt;&lt;/span&gt;
		&lt;/div&gt;
		...
	&lt;/div&gt;
                        </code></pre>
					</section>

					<section>
						<h2>새로운 블록 만들기</h2>
                        <pre><code class="html">
	&lt;!-- Good --&gt;
	&lt;div class="stick-man"&gt;
		...
		&lt;div class="arms"&gt;
			&lt;span class="arms__left"&gt;&lt;/span&gt;
			&lt;span class="arms__right"&gt;&lt;/span&gt;
		&lt;/span&gt;
		...
	&lt;/div&gt;
                        </code></pre>
					</section>

					<section>
                        <pre><code class="html">
	&lt;!-- Bad --&gt;
	&lt;div class="stick-man"&gt;
		...
		&lt;div class="stick-man-arms"&gt;
			&lt;span class="stick-man-arms__left"&gt;&lt;/span&gt;
			&lt;span class="stick-man-arms__right"&gt;&lt;/span&gt;
		&lt;/div&gt;
		...
	&lt;/div&gt;

	&lt;!-- 블록 이동을 시도 할 때, 이상한 이름으로 문제 발생 --&gt;
	&lt;div class="iron-man"&gt;
		...
		&lt;div class="stick-man-arms"&gt;
			&lt;span class="stick-man-arms__left"&gt;&lt;/span&gt;
			&lt;span class="stick-man-arms__right"&gt;&lt;/span&gt;
		&lt;/div&gt;
		...
	&lt;/div&gt;
                        </code></pre>
					</section>

					<section>
						<h2>하나의 중첩된 요소로 BEM-트리 만들기</h2>
                        <pre><code class="html">
	&lt;!-- Good --&gt;
	&lt;div class="stick-man"&gt;
		...
		&lt;div class="stick-man__arms"&gt;
			&lt;span class="stick-man__left"&gt;&lt;/span&gt;
			&lt;span class="stick-man__right"&gt;&lt;/span&gt;
		&lt;/div&gt;
		...
	&lt;/div&gt;
                        </code></pre>
					</section>

					<section>
						<h2>DOM 트리</h2>
                        <pre><code class="html">
	&lt;ul&gt;
		&lt;li&gt;
			&lt;a&gt;
				&lt;span&gt;&lt;/span&gt;
			&lt;/a&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
                        </code></pre>
                       	<pre><code class="css">
	.ul {}
	.ul > li {}
	.ul > li > a {}
	.ul > li > a > span {}
                        </code></pre>
					</section>

					<section>
						<h2>BEM 트리</h2>
                        <pre><code class="html">
	&lt;ul class="menu"&gt;
		&lt;li class="menu__item"&gt;
			&lt;a class="menu__link"&gt;
				&lt;span class="menu__text"&gt;&lt;/span&gt;
			&lt;/a&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
                        </code></pre>
                       	<pre><code class="css">
	.menu {}
	.menu__item {}
	.menu__link {}
	.menu__text {}
                        </code></pre>
					</section>


					<section>
						<h2>Modifier</h2>
						<ul>
							<li>블록, 요소에 대해 추가 변형을 제공 (외형, 상태)</li>
							<li>클래스명은 블록 또는 요소 이름 옆에 하이픈 두 개(--) 추가 후 작성</li>
						</ul>
					</section>


					<section>

						<div><img src="img/stick_man_m.png" alt="" style="width:50%;margin:0"></div>

						<pre><code class="html">
	&lt;div class="stick-man stick-man--blue"&gt; ... &lt;/div&gt;
	&lt;div class="stick-man stick-man--red"&gt; ... &lt;/div&gt;
                        </code></pre>

                        <pre><code class="css">
	/* Block modifier */
	.stick-man--blue { ... }
	.stick-man--red { ... }
	.stick-man--red .stick-man__head { ... }
                        </code></pre>
					</section>

					<section>
						<div><img src="img/stick_man_m2.png" alt="" style="width:50%;margin:0"></div>

						<pre><code class="html">
	&lt;div class="stick-man"&gt;
		&lt;div class="stick-man__head stick-man__head--small"&gt;&lt;/div&gt;
		또는..
		&lt;div class="stick-man__head stick-man__head--big"&gt;&lt;/div&gt;
	&lt;/div&gt;
                        </code></pre>

                        <pre><code class="css">
	/* Element modifier */
	.stick-man__head--small { ... }
	.stick-man__head--big { ... }
                        </code></pre>
					</section>

				</section>


				<section>
					<section>
						<h2>SMACSS<br>(Scalable and Modular Architecture for CSS)</h2>
					</section>

					<section>
						<h2>SMACSS</h2>
						<p>CSS를 모듈화하고 확장 가능하게 만드는 것을 목표</p>
						<!-- <p>CSS를 보다 체계적이고, 범주화함으로써 쉽게 유지보수 하는 것을 목표</p> -->

						<ul>
							<li>OOCSS, BEM의 핵심 컨셉을 차용하고 좀 더 자세한 사항 추가</li>
							<li>클래스명을 통한 예측, 재사용, 쉬운 유지보수, 확장성을 통해 스타일 체계화</li>
							<!-- <li>CSS의 프레임워크가 아닌 하나의 스타일 가이드</li> -->
							<!-- <li>후속의 접근법들</li> -->
							<!-- <li>BEM과 같은 접근법은 이 결정법중 몇가지를 차용 더 쉽게 적용이 가능 하도록</li> -->
						</ul>
<!--
내가 생각하는 SMACSS의 주요내용 이렇다.

하나의 사이트에서 공통으로 적용되는 Base가 되는 css의 집합을 만든다.
예) reset.css

css 이름은 콘텐츠와 직접적으로 연관되고, 이름만으로 어떤 콘텐츠인지 알 수 있도록 해야 한다.

– 접두사를 사용하여 레이아웃, 모듈, 상태 여부를 알 수 있도록 : layout-, module-, is-
– layout-fixed, module-pop, module-login 등

마크업시 재사용이 가능하도록 Id보다는 class로 설정한다.

기능단위로 묶어서 css를 작성한다.
– 특히 반응형 웹 적용시 mediaquery 해상도에 따라 파일을 나누거나 하는 경우가 많은데, 이는 유지보수 및 공동작업 시 혼란(?) 혹은 번거로움을 야기한다.

따라서 기능단위로 그룹화하여 mediaquery 까지 묶어서 작성한다.
– class가 추가되는 경우에는 해당 그룹에 추가하면 된다.

Theme 관련해서는 color등 변경되는 class만 모아서 파일로 관리하면 Theme 생성, 업데이트가 용이할 것임.
– 기본 Theme에 나중에 작성한 css파일이 덮어쓰기 되는 형식
 -->

					</section>

					<section>
						<h2>SMACSS의 핵심은 분류</h2>
						<p>5개의 구분된 카테고리로 CSS 코딩 기법 제시<br>어떤 카테고리에 스타일이 속하는지 결정하는데 숙고 요구</p>
						<ul>
							<li>Base - 기본 규칙</li>
							<li>Layout - 레이아웃 규칙</li>
							<li>Module - 모듈 규칙</li>
							<li>State - 상태 규칙</li>
							<li>Theme - 테마 규칙</li>
						</ul>
					</section>


					<section>
						<h2>Base - 기본 규칙</h2>
						<ul>
							<li>각 브라우저의 스타일을 초기화 시키는 목적으로 사용</li>
							<li>요소(elements) 스타일의 기본값 지정 (reset.css, normalize.css)</li>
						</ul>

						<pre><code class="css">
	body,p,h1,h2,h3,h4,h5,h6,ul,ol,li,dl,dt,dd,table,th,td,form,fieldset,legend,input,
	textarea,button,select{margin:0;padding:0}
	body,input,textarea,select,button,table{font-family:AppleGothic,'돋움',Dotum,sans-seriffont-size:14px;line-height:1.25}
	...
                        </code></pre>
					</section>

					<section>
						<h2>Layout - 레이아웃 규칙</h2>
						<ul>
							<li>큰 틀의 레이아웃, 페이지의 다양한 요소를 배치, 구별하는데 사용</li>
							<li>주요 컴포넌트 : header, footer, content, aside.. etc</li>
							<li>하위 컴포넌트 : 주요 컴포넌트 내에 있는 컴포넌트 (nav, item list, form.. etc)</li>
							<li>주요 컴포넌트는 id 셀렉터, 하위 컴포넌트 class 셀렉터로 스타일 작성</li>
							<li>클래스명은 접두사로 l-, layout- 명시 요구</li>
						</ul>

						<pre><code class="css">
	/* ex) l-fixed 유무에 따라 가변 폭으로 할지 고정 폭으로 할지 결정하는 레이아웃 */
	#content {width:80%;float:left}
	#aside {width:20%}

	.l-fixed #content {
		width: 600px;
		margin-right: 10px;
	}
	.l-fixed #aside {
		width: 200px
	}
                        </code></pre>
					</section>

					<section>
						<h2>Module - 모듈 규칙</h2>
						<ul>
							<li>페이지에서 재사용 가능한 구성요소 (버튼, 위젯, 배너.. 등)</li>
							<li>모듈은 레이아웃 구성요소 안에 존재 하지만 다른 모듈에도 존재 할 수 있음</li>
							<li>각 모듈은 독립형으로 존재하도록 설계</li>
							<li>재사용을 위해 CSS선택자로 id, 태그를 사용하지 않음</li>
						</ul>

                        <pre><code class="html">
	&lt;div class="box"&gt;
		&lt;span class="box-name"&gt; ... &lt;/span&gt;
		&lt;span class="box-items"&gt; ... &lt;/span&gt;
	&lt;/div&gt;
                        </code></pre>
                        <pre><code class="css">
	.box { ... }
	.box-name { ... }
	.box-items { ... }
                        </code></pre>
					</section>

					<!--
					<section>
						<h2>태그 선택자 사용하지 않기</h2>
						<p>프로젝트 규모가 커질수록 다른 태그로 바꿔야 할 수도 있고 태그 본연의 특징을 유지하기 어려울 수 있음</p>
						<ul>
							<li>프로젝트가 복잡해 질수록 구성요소의 기능을 확장해야 할 가능성 증가</li>
							<li>만약, 태그 선택자를 사용해야 한다면 .box > span 처럼 하위 선택자 사용</li>
						</ul>
                        <pre class="vertical"><code class="css">
	/* Bad */
	.box span {
		padding: 5px;
	}



	.box > span {
		padding-left: 20px;
		background: url(icon.png);
	}
                        </code></pre>
						<pre class="vertical"><code class="html">
	&lt;!-- 기존 --&gt;
	&lt;div class="box"&gt;
		&lt;span&gt;Box Name&lt;/span&gt;
	&lt;/div&gt;


	&lt;!-- 새로 추가 될 경우 --&gt;
	&lt;div class="box"&gt;
		&lt;span&gt;Box Name&lt;/span&gt;
		&lt;span&gt;Box Item(10)&lt;/span&gt;
	&lt;/div&gt;
                        </code></pre>
					</section>
					-->

					<section>
						<h2>State - 상태 규칙</h2>
						<ul>
							<li>요소의 상태 변화를 표현하는 스타일 (툴팁, 아코디언)</li>
							<li>주로 Javascript으로 조작되는 클래스 지정</li>
							<li>클래스명은 접두사로 is- 등을 명시 (is-hidden, is-collapsed)</li>
							<li>모듈과 레이아웃 둘 다 적용 가능</li>
						</ul>

						<pre><code class="html">
	&lt;!-- 레이아웃 요소, 접힌 상태 --&gt;
	&lt;div id="header" class="is-collapsed"&gt;
		&lt;form&gt;
			&lt;!-- 모듈, 오류 상태 --&gt;
			&lt;div class="msg is-error"&gt;
				There is an error!
			&lt;/div&gt;
			&lt;!-- 연관된 라벨이 숨겨진 상태 --&gt;
			&lt;label for="search" class="is-hidden"&gt;Search&lt;/label&gt;
			&lt;input type="text" id="search"&gt;
		&lt;/form&gt;
	&lt;/div&gt;
                        </code></pre>
					</section>

					<section>
						<h2>Theme - 테마 규칙</h2>
						<ul>
							<li>사용자가 테마를 선택할 수 있는 경우 사용</li>
							<li>색상, 이미지를 불변하는 스타일과 분리 (background, color, border..)</li>
							<li>메인 스타일 뒤에 읽어 들이게 하고 덮어쓰기를 하거나 기존 스타일을 재선언하여 사용</li>
							<li>theme- 등의 접두어를 명시 또는 theme/과 같은 디렉토리로 계층 분리</li>
							<li>자주 사용되지는 않음</li>
						</ul>

                        <pre><code class="css">
	/* main.css */
	.box {
		border: 1px solid;
	}
                        </code></pre>
                        <pre><code class="css">
	/* theme.css - main.css 뒤에서 읽도록 */
	.box {
	    border-color: blue;
	}
                        </code></pre>

					</section>

				</section>

<!--
좋은습관/나쁜습관
좋은 습관
Component Library를 이용하여 HTML을 구성하자. (like lego)
http://pflannery.github.io/oocss-skeleton.docpad/oocss/help/components.html
semantic 스타일을 지속적으로 사용하자
내부에 종속되지 않도록 모듈을 디자인하자
코드를 유연하게 (width는 container가 제어하고, height은 contents가 제어하도록)
Grid를 사랑하는 습관을 갖자. http://jsfiddle.net/inuitcss/CLYUC/l
선택자(selector) 사용은 최소화하자
여러개의 클래스를 적용하여 확장성을 열어두자
CSS Lint를 사용해서 코드를 검사하자
구조와 스킨을 독립적으로 관리(위에서 설명)
컨테이너와 컨텐츠를 구분하자(위에서 설명)
Reset and fonts를 사용하자 (ex. YUI)
나쁜 습관
의존적인 스타일을 피하자
CSS

1
.class p{…}
css에 html 태그를 적지 말자
CSS

div.classname{…}
p.classname{…}
ID 사용은 피하자
모든 이미지를 스프라이트 하지 말자
높이를 고정 시킨 상태에서의 정렬을 피하자
텍스트를 이미지로 사용하지 말자
너무 이른 최적화는 피하자
쓸모 없는 것을 두 번 반복해서 사용하지 말자
 -->

				<section>
					<h2>방법론은 방법론일 뿐..</h2>
					<p>보시다시피, 이러한 접근법 중에서 완벽하게 이상적인 것은 없음<br>따라서 이 방법들 중 어느 것도 절대적인 규칙이 아님</p>
				</section>

				<section>
					<h2>정리</h2>
					<p>각각의 방법론에는 장/단점이 존재하기 때문에<br>프로젝트에 따라 나만의 방법론, 팀의 방법론을 만들어 가는것이 중요함</p>
					<!-- <p>분명한 점은 앞으로 CSS를 작성 할 때 한번 더 생각할 것이고, 고민 할 것이다.</p> -->
				</section>

				<section>
					<h1>감사합니다.</h1>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>
		<script>
			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'convex', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

			Reveal.addEventListener( 'slidechanged', function(event) {
				// event.previousSlide, event.currentSlide, event.indexh, event.indexv
				var notes = event.currentSlide.querySelector(".notes");
				if(notes) {
					console.info(notes.innerHTML.replace(/\n\s+/g,'\n'));
				}
			});
		</script>
	</body>
</html>